# -*- coding: utf-8 -*-
"""Web Mapping.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ugfa7_j677-uERRTgGjW4FUViP1vUg3n

#Installation des Librairies
"""

!pip install streamlit
!pip install folium
!pip install geopandas
!pip install streamlit-folium
!pip install rasterio
!pip install streamlit_lottie
!pip install json
!pip install requests
!pip install GDAL==$(gdal-config --version)
!pip install branca.colormap
!pip install numpy
!pip install selenium
!pip install --upgrade rasterio
!pip install leafmap
!pip install streamlit pillow rasterio

"""**Main**

#Code streamlit

***Pour visualiser le code il faut ecrire au début du code:***
%%writefile nom de votre fichier.py
"""

#%%writefile vecteur.py
import streamlit as st
import geopandas as gpd
import folium
from streamlit_folium import folium_static
import pandas as pd
import altair as alt
import requests
import json
from streamlit_lottie import st_lottie
from folium import plugins
from branca.colormap import LinearColormap
import matplotlib.pyplot as plt
import numpy as np
import rasterio
import glob
import geopy.distance
import imageio
from PIL import Image, ImageDraw
import leafmap.foliumap as leafmap
import os
from streamlit_folium import folium_static as st_folium_static
import math
import time
import tempfile
import uuid
from decimal import Decimal
from rasterio.plot import reshape_as_raster, reshape_as_image

# Set page configuration
st.set_page_config(
    page_title='Climat Maroc',
    layout="wide",
    page_icon="/content/icon.png",
    # initial_sidebar_state="collapsed"
)
st.markdown(
    """
    <style>
        .orange-text {
            color: 	#FF2E00;  /* Couleur orange */
        }

        h1 {
            text-align: left;
            color: #FF2E00;  /* Couleur orange pour les titres */
        }
        h4 {
            text-align: left;
            color: #ffffff;  /* Couleur orange pour les titres */
        }
        .tt-text {
           text-align: center;
        }
        .lineaire-simple {
          background: linear-gradient(#0098FF, #FF2E00);
         }
        h3{
            text-align: center;
            color: 	#00CED1;  /* Couleur orange pour les titres */
        }
        .turquoise-text {
            color:#00CED1;  /* Couleur orange */
        }


    </style>
    """,
      unsafe_allow_html=True)

cl1,cl2=st.columns([0.1,2])
with cl1:
  def load_lottie(file_path: str):
    with open(file_path,"r") as f:
        return json.load(f)
  anim=load_lottie("/content/Anim.json")
  st_lottie(anim, speed=1, reverse=False, loop=True, quality="high", height=75, width=75, key=None)
with cl2:
  st.markdown("<h1 class='orange-text'> Cartographier Météo Maroc </h1>", unsafe_allow_html=True)

tab1, tab2, tab3,tab4 = st.tabs(["Acceuil", "Cartes vecteur", "Cartes Raster","Comparaison"])
with tab1:

 st.markdown(
    """
    <style>
        .orange-text {
            color: 	#FF2E00;  /* Couleur orange */
        }
        .container-style {
            background-color: #FFFFFF;  /* Couleur blanche */
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        .blue-text {
            color: #FFD700;  /* Couleur orange */
        }
        h2 {
            text-align: center;
            color: 	#FF0000;  /* Couleur orange pour les titres */
        }
        h4 {
            text-align: center;
            color: #B22222;  /* Couleur orange pour les titres */
        }
        h6{
            text-align: center;
            color: 	#8B0000;  /* Couleur orange pour les titres */
        }


    </style>
    """,
      unsafe_allow_html=True
  )

 with st.container():
    st.markdown("<h2 class='orange-text'> Construire un Dataset Géospatial avec Geoparquet</h2>", unsafe_allow_html=True)
    st.markdown("Ensemble, nous allons construire un dataset robuste contenant des informations sur la température, l'humidité et les précipitations de 1009 points répartis au Maroc sur 12 mois. Utilisons le format Geoparquet pour exploiter pleinement les avantages du partitionnement des données.")

 with st.container():
    st.markdown("<h4 class='orange-text'> Analysez et Cartographiez les Données</h4>", unsafe_allow_html=True)
    colo1, colo2, colo3 = st.columns(3)
    with colo1:
        st.markdown("<h6 class='blue-text'> Choix de la colonne </h6>", unsafe_allow_html=True)
        st.markdown("Décidez quelle colonne de données vous souhaitez cartographier pour mettre en évidence les variations géographiques des conditions climatiques.")
    with colo2:
        st.markdown("<h6 class='blue-text'>Navigation Inituitive </h6>", unsafe_allow_html=True)
        st.markdown("Explorez facilement les données mois par mois en utilisant un Slider, des Timelapses et une fonctionnalité de SplitMap pour comparer les cartes.")
    with colo3:
        st.markdown("<h6 class='blue-text'>Interaction Visuelle </h6>", unsafe_allow_html=True)
        st.markdown("Améliorez l'expérience utilisateur en ajoutant des pop-ups interactifs contenant des graphes linéaires liés aux données des 12 mois.")

 with st.container():
    st.markdown("<h4 class='orange-text'> Optimisez vos Recherches et Filtrages</h4>", unsafe_allow_html=True)
    colo1, colo2, colo3 = st.columns(3)
    with colo1:
        st.markdown("<h6 class='blue-text'> Recherche Rapide</h6>", unsafe_allow_html=True)
        st.markdown("Trouvez rapidement les coordonnées vous souhaitez cartographier en utilisant notre fonction de recherche par boîte de texte.")
    with colo2:
        st.markdown("<h6 class='blue-text'> Données Ciblées</h6>", unsafe_allow_html=True)
        st.markdown("Filtrez précisément les données qui vous intéressent en utilisant des requêtes spécifiques pour accéder aux informations pertinentes.")
    with colo3:
        st.markdown("<h6 class='blue-text'> Export Simple</h6>", unsafe_allow_html=True)
        st.markdown("Exportez facilement le résultat de votre requête sous format geojson pour un partage avec d'autres utilisateurs.")


with tab2:
 col1, col2 = st.columns([0.5,2])

# Sidebar in col1
 with col1:
    st.markdown("Filtre")
    file_pathP = "/content/climatdata.parquet"
    gdf = gpd.read_parquet(file_pathP)
    selected_attribute = st.selectbox("Choisir un attribut",gdf.columns[11:])
    m = folium.Map(location=[31.7917, -7.0926], zoom_start=5.5,control_scale=True, max_zoom=8,min_zoom=5)
    option = st.radio("Choisir une option", ['Symboles Proportionnels', 'Graphes Symboles'])
    search_coordinates = st.text_input("Rechercher par coordonnées (latitude, longitude)", "")
    if search_coordinates:
        try:
            lat, lon = map(float, search_coordinates.split(','))
            st.sidebar.success(f"Rechercher par coordonnées: Latitude {lat}, Longitude {lon}")

            # Add a marker at the searched coordinates
            folium.Marker(
                location=[lat, lon],
                popup=f"Recherche des coordonnées: {lat}, {lon}",
                icon=folium.Icon(color='red')
            ).add_to(m)

            m.location = [lat, lon]
            m.zoom_start = 1 # Adjust the zoom level as needed
        except ValueError:
            st.sidebar.error("Invalid coordinates format. Please enter coordinates as 'latitude, longitude'.")
    filter_option = st.selectbox("Requête:", ["Aucun", "Attributs", "Spatial"])
    if filter_option == "Attributs":
        attribute_to_filter = st.selectbox("Choisir un attribut pour filtrer:", gdf.columns)

        if 11 <= gdf.columns.get_loc(attribute_to_filter) <= 47:
            min_value = st.text_input(f"Valeur minimale de {attribute_to_filter}:", "")
            max_value = st.text_input(f"Valeur maximale de {attribute_to_filter}:", "")

            if st.button("Appliquer le filtre attributaire"):
                try:
                    # Convertir les colonnes numériques en float
                    gdf[attribute_to_filter] = gdf[attribute_to_filter].astype(float)

                    if min_value and max_value:
                        gdf = gdf[(gdf[attribute_to_filter] >= float(min_value)) & (gdf[attribute_to_filter] <= float(max_value))]
                    elif min_value:
                        gdf = gdf[gdf[attribute_to_filter] >= float(min_value)]
                    elif max_value:
                        gdf = gdf[gdf[attribute_to_filter] <= float(max_value)]
                except ValueError as ve:
                    st.error(f"Erreur lors de la conversion des valeurs en float : {str(ve)}")
        else:
            # Non-numeric attribute filter with single value
            attribute_value = st.text_input(f"Valeur de {attribute_to_filter}:", "")

            if st.button("Appliquer le filtre attributaire"):
                if attribute_value:
                    gdf = gdf[gdf[attribute_to_filter] == attribute_value]





    elif filter_option == "Spatial":
        # Spatial filter
        st.warning("Saisissez une requête spatiale(syntaxe GeoPandas).")
        user_spatial_query = st.text_input("Requête spatiale:", "")
         # Exemple:(geometry.x > -7.5) & (geometry.x < -7)

        if user_spatial_query:
                try:
                    gdf = gdf.query(user_spatial_query)
                    st.success("Filtre spatial appliqué avec succès.")

                    # Download button for the GeoJSON file
                    download_button = st.download_button(
                        label="Télécharger le résultat en GeoJSON",
                        data=gdf.to_json(),
                        file_name="result.geojson",
                        key="geojson_download",
                    )
                except Exception as e:
                    st.error(f"Erreur lors de l'application du filtre spatial: {str(e)}")




# Main content in col2
 with col2:
    st.markdown("Résultat")
    def flannery_compensation(original_size, attribute_value):
        return original_size * math.sqrt(attribute_value / math.pi)
    if option == 'Graphes Symboles':
        st.write("Cliquer sur le points pour afficher le graphe.")
        for index, row in gdf.iterrows():
            marker = folium.CircleMarker(location=[row.geometry.y, row.geometry.x], radius=1, color='red', fill=True, fill_color='red',)
            month_mapping = {1: 'Janvier',2: 'Février',3: 'Mars',4: 'Avril',5: 'Mai',6: 'Juin',7: 'Juillet',8: 'Août',9: 'Septembre',10: 'Octobre',11: 'Novembre',12: 'Décembre'}
            data = {
                'Mois':[month_mapping[i] for i in range(1, 13)],
                'Température Moyenne (en °)': row[[f'Température M{i}' for i in range(1, 13)]].values,
                'Précipitations (en mm)': row[[f'Précipitations{i}' for i in range(1, 13)]].values,
                'Humidité (en %)': row[[f'Humidité{i}' for i in range(1, 13)]].values}
            df = pd.DataFrame(data)
            df['Température Moyenne (en °)'] = df['Température Moyenne (en °)'].apply(float)
            df['Précipitations (en mm)'] = df['Précipitations (en mm)'].apply(float)
            df['Humidité (en %)'] = df['Humidité (en %)'].apply(lambda x: float(x) * 100)
            df_chart = pd.DataFrame(df).melt('Mois')
            chart = alt.Chart(df_chart).mark_line().encode(
                x='Mois',
                y='value:Q',
                color='variable:N', ).properties(width=300, height=150)
            popup = folium.Popup(max_width=0).add_child(folium.VegaLite(chart, width=10, height=10))

            df_chart = pd.DataFrame(df).melt('Mois')
            chart = alt.Chart(df_chart).mark_line().encode(
               x='Mois',
               y='value:Q',
               color='variable:N',
            ).properties(width=200, height=100)
            popup = folium.Popup(max_width=350).add_child(folium.VegaLite(chart, width=350, height=150))
            marker.add_child(popup)
            value = row[f"{selected_attribute}"]
            value=float(Decimal(value))
            original_size = 2  # Ajustez la taille d'origine du symbole en conséquence
            radius = flannery_compensation(original_size, value)# Adjust the multiplier based on your data
            color = 'darkturquoise' # You can customize the color based on your needs
            folium.CircleMarker(
                    location=[row.geometry.y, row.geometry.x],
                    radius=radius,
                    color=color,
                    fill=True,
                    fill_color=color,
                    fill_opacity=0.6,
                    popup =popup,
            ).add_to(m)
        folium.plugins.MousePosition().add_to(m)
        folium_static(m, width=1200, height=800)
    elif option == 'Symboles Proportionnels':
        st.write(f"Cliquer sur le points pour afficher la valeur de {selected_attribute}.")
        for index, row in gdf.iterrows():
            value = row[f"{selected_attribute}"]
            value = float(Decimal(value))
            original_size = 2  # Ajustez la taille d'origine du symbole en conséquence
            radius = flannery_compensation(original_size, value)# Adjust the multiplier based on your data
            color = 'darkturquoise' # You can customize the color based on your needs

            folium.CircleMarker(
                location=[row.geometry.y, row.geometry.x],
                radius=radius,
                color=color,
                fill=True,
                fill_color=color,
                fill_opacity=0.6,
                popup=f"{selected_attribute}: {value}",
            ).add_to(m)

        folium.plugins.MousePosition().add_to(m)
        draw = folium.plugins.Draw(export=True)
        draw.add_to(m)
        folium_static(m, width=1200, height=600)
with tab3:
 with st.container():
    month_mapping = {1: 'Janvier', 2: 'Février', 3: 'Mars', 4: 'Avril', 5: 'Mai', 6: 'Juin', 7: 'Juillet', 8: 'Août', 9: 'Septembre', 10: 'Octobre', 11: 'Novembre', 12: 'Décembre'}
    NoDataValue = -9999
    def read_geotiff(file_path):
      dataset = rasterio.open(file_path)
      return dataset
    def convert_to_streamlit_image(data):
      normalized_data = (data - data.min()) / (data.max() - data.min())
      return normalized_data
    def create_mask(data, temperature_thresholds):
      mask = np.zeros_like(data, dtype=bool)
      for threshold in temperature_thresholds:
        mask |= (data == threshold)
      return mask

    def create_folium_mapT(dataset, file_path, colormap_name='viridis', temperature_thresholds=[7, 8, 9, 10, 11, 12, 13, 14, 15,16,17,18,19,20,21,22,23,24,25,26]):
      m = folium.Map(location=[31.7917, -7.0926], zoom_start=5.3,control_scale=True, max_zoom=6,min_zoom=2)
      raster_data = dataset.read(1)

    # Masquer les valeurs égales à "NoData"
      raster_data_masked = np.ma.masked_where(raster_data == NoDataValue, raster_data)

      mask = create_mask(raster_data_masked, temperature_thresholds)

      cmap = plt.get_cmap(colormap_name)
      norm = plt.Normalize(vmin=raster_data_masked.min(), vmax=raster_data_masked.max())
      cmap._init()
      cmap._lut[:-3, -1] = np.linspace(0, 1, cmap.N)

      fig, ax = plt.subplots()
      img = ax.imshow(raster_data_masked, cmap=cmap, norm=norm)
      image_overlay = folium.raster_layers.ImageOverlay(
        image=img.to_rgba(raster_data_masked.filled(fill_value=-9999), bytes=True, norm=True),
        bounds=[[dataset.bounds.bottom, dataset.bounds.left],
                [dataset.bounds.top, dataset.bounds.right]],
        colormap=cmap,
      )
      image_overlay.add_to(m)

      colormap = LinearColormap(
        colors=[cmap(norm(value)) for value in range(int(raster_data_masked.min()), int(raster_data_masked.max()) + 1)],
        vmin=raster_data_masked.min(),
        vmax=raster_data_masked.max()
      )
      colormap.add_to(m)
      plugins.MousePosition().add_to(m)
      return m

    def create_folium_mapP(dataset, file_path, colormap_name='viridis', temperature_thresholds=[0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1]):
          m = folium.Map(location=[31.7917, -7.0926], zoom_start=5.3, control_scale=True, max_zoom=6, min_zoom=2)
          raster_data = dataset.read(1)

          # Masquer les valeurs égales à "NoData"
          raster_data_masked = np.ma.masked_where(raster_data == NoDataValue, raster_data)

          mask = create_mask(raster_data_masked, temperature_thresholds)

          cmap = plt.get_cmap(colormap_name)
          norm = plt.Normalize(vmin=raster_data_masked.min(), vmax=raster_data_masked.max())
          cmap._init()
          cmap._lut[:-3, -1] = np.linspace(0, 1, cmap.N)

          fig, ax = plt.subplots()
          img = ax.imshow(raster_data_masked, cmap=cmap, norm=norm)

          # Get a list of colors for the colormap
          colors = [cmap(norm(value)) for value in np.linspace(raster_data_masked.min(), raster_data_masked.max(), 256)]

          image_overlay = folium.raster_layers.ImageOverlay(
              image=img.to_rgba(raster_data_masked.filled(fill_value=-9999), bytes=True, norm=True),
              bounds=[[dataset.bounds.bottom, dataset.bounds.left],
                      [dataset.bounds.top, dataset.bounds.right]],
              colormap=LinearColormap(colors=colors, vmin=raster_data_masked.min(), vmax=raster_data_masked.max())
          )
          image_overlay.add_to(m)

          colormap = LinearColormap(
              colors=colors,
              vmin=raster_data_masked.min(),
              vmax=raster_data_masked.max()
          )
          colormap.add_to(m)
          plugins.MousePosition().add_to(m)
          return m



    def create_folium_mapH(dataset, file_path, colormap_name='viridis', temperature_thresholds=[0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9,0.95, 1]):
      m = folium.Map(location=[31.7917, -7.0926], zoom_start=5.3,control_scale=True, max_zoom=6,min_zoom=2)
      raster_data = dataset.read(1)

    # Masquer les valeurs égales à "NoData"
      raster_data_masked = np.ma.masked_where(raster_data == NoDataValue, raster_data)

      mask = create_mask(raster_data_masked, temperature_thresholds)

      cmap = plt.get_cmap(colormap_name)
      norm = plt.Normalize(vmin=raster_data_masked.min(), vmax=raster_data_masked.max())
      cmap._init()
      cmap._lut[:-3, -1] = np.linspace(0, 1, cmap.N)

      fig, ax = plt.subplots()
      img = ax.imshow(raster_data_masked, cmap=cmap, norm=norm)
      image_overlay = folium.raster_layers.ImageOverlay(
        image=img.to_rgba(raster_data_masked.filled(fill_value=-9999), bytes=True, norm=True),
        bounds=[[dataset.bounds.bottom, dataset.bounds.left],
                [dataset.bounds.top, dataset.bounds.right]],
        colormap=cmap,
      )
      image_overlay.add_to(m)

      colormap = LinearColormap(
        colors=[cmap(norm(value)) for value in np.linspace(raster_data_masked.min(), raster_data_masked.max(), num=10)],
        vmin=raster_data_masked.min(),
        vmax=raster_data_masked.max()
      )
      colormap.add_to(m)
      plugins.MousePosition().add_to(m)
      return m

    def main():
      st.markdown("<h4 class='tt-text'> Visualisation des données par Slider </h4>", unsafe_allow_html=True)
      selected_attribute = st.selectbox("Choisir un attribut: ", ["Température", "Précipitations", "Humidité"])
      selected_month_index = st.select_slider("Selectionnez le mois souhaité ", options=list(month_mapping.keys()), format_func=lambda x: month_mapping[x])
      file_path = f'/content/{selected_attribute}/{selected_attribute}{selected_month_index}.tif'
      dataset = read_geotiff(file_path)
      if selected_attribute == "Température":
          folium_map = create_folium_mapT(dataset, file_path)
      elif selected_attribute == "Précipitations":
          folium_map = create_folium_mapP(dataset, file_path)
      else:
          folium_map = create_folium_mapH(dataset, file_path)
      st.components.v1.html(folium_map.get_root().render(), height=600)


    if __name__ == "__main__":
      main()
 with st.container():
     st.markdown("<h4 class='tt-text'> Visualisation des données par Timelapse </h4>", unsafe_allow_html=True)
     selected_attribute_T = st.selectbox("Selectionner un attribut: ", ["Température", "Précipitations", "Humidité"])
     def create_mask(data, temperature_thresholds):
      mask = np.zeros_like(data, dtype=bool)
      for threshold in temperature_thresholds:
        mask |= (data == threshold)
      return mask

     def load_images(folder):
      image_files = sorted(glob.glob(folder + '/*.tif'))
      return image_files

     def create_timelapse(image_files, month_names, fps, colormap_name='viridis'):
       images = []
       for i, file in enumerate(image_files):
        with rasterio.open(file) as src:
            image_data = src.read(1)
            rgba_image = plt.cm.get_cmap(colormap_name)((image_data / np.max(image_data)))
            rgba_image = (rgba_image[:, :, :3] * 255).astype('uint8')

            # Convert numpy array to PIL Image
            pil_image = Image.fromarray(rgba_image)

            # Create a drawing object
            draw = ImageDraw.Draw(pil_image)

            # Annotate each frame with month names
            draw.text((10, 10), month_names[i], fill='white', font=None)

            # Convert PIL Image back to numpy array
            rgba_image = np.array(pil_image)

            images.append(rgba_image)

       with imageio.get_writer('timelapse.gif', mode='I', duration=100, loop=0, fps=fps) as writer:
        for image in images:
            writer.append_data(image)
     month_names = ['Janvier', 'Février', 'Mars','Avril','Mai','Juin','Juillet','Août','Septembre','Octobre','Novembre','Décembre']
     folder = f"/content/{selected_attribute_T}"
     image_files = load_images(folder)
     create_timelapse(image_files, month_names, fps=10, colormap_name='viridis')
     first_image = image_files[0]
     with rasterio.open(first_image) as src:
      bounds = [[src.bounds.bottom, src.bounds.left], [src.bounds.top, src.bounds.right]]
     with st.container():
       m = folium.Map(location=[28.7917, -9.6026], zoom_start=5,control_scale=True, max_zoom=6,min_zoom=3)
       gif_filename = 'timelapse.gif'
       gif_layer = folium.raster_layers.ImageOverlay(
         gif_filename,
         bounds=bounds,
         opacity=0.7,
         name='GIF Layer'
       ).add_to(m)
     folium.LayerControl().add_to(m)
     folium_static(m, width=1500, height=800)

 with st.container():
     NoDataValue = -9999  # Replace this with your actual NoDataValue

     def create_mask(data, temperature_thresholds):
         mask = np.zeros_like(data, dtype=bool)
         for threshold in temperature_thresholds:
             mask |= (data == threshold)
         return mask
     def create_folium_map(dataset, file_path, colormap_name='viridis', temperature_thresholds=[7, 8, 9, 10, 11, 12, 13, 14, 15,16,17,18,19,20,21,22,23,24,25,26]):
         m = folium.Map(location=[31.7917, -7.0926], zoom_start=2,control_scale=True, max_zoom=10,min_zoom=4)
         raster_data = dataset.read(1)
         raster_data_masked = np.ma.masked_where(raster_data == NoDataValue, raster_data)
         mask = create_mask(raster_data_masked, temperature_thresholds)
         cmap = plt.get_cmap(colormap_name)
         norm = plt.Normalize(vmin=raster_data_masked.min(), vmax=raster_data_masked.max())
         cmap._init()
         cmap._lut[:-3, -1] = np.linspace(0, 1, cmap.N)
         fig, ax = plt.subplots()
         img = ax.imshow(raster_data_masked, cmap=cmap, norm=norm)
         image_overlay = folium.raster_layers.ImageOverlay(
             image=img.to_rgba(raster_data_masked.filled(fill_value=-9999), bytes=True, norm=True),
             bounds=[[dataset.bounds.bottom, dataset.bounds.left],
                     [dataset.bounds.top, dataset.bounds.right]],
             colormap=cmap,
         )
         image_overlay.add_to(m)

         colormap = LinearColormap(
             colors=[cmap(norm(value)) for value in range(int(raster_data_masked.min()), int(raster_data_masked.max()) + 1)],
             vmin=raster_data_masked.min(),
             vmax=raster_data_masked.max()
         )
         colormap.add_to(m)
         plugins.MousePosition().add_to(m)
         return m

     st.markdown("<h4 class='tt-text'> Comparaison des données par SplitMap </h4>", unsafe_allow_html=True)

     selected_attribute = st.selectbox("Selectionner Attribut ", ["Température", "Précipitations", "Humidité"])
     image_name_left = st.selectbox("Selectionnez image à droite:", [f"{selected_attribute}{i}.tif" for i in range(1, 13)])
     image_name_right = st.selectbox("Selectionnez image à gauche:", [f"{selected_attribute}{i}.tif" for i in range(1, 13) if f"{selected_attribute}{i}.tif" != image_name_left])
     colormap_name = 'viridis'
     image_name_left = f'https://amaajanehajar.github.io/Rendred/{selected_attribute}/{image_name_left}'
     image_name_right = f'https://amaajanehajar.github.io/Rendred//{selected_attribute}/{image_name_right}'

     viridis_palette = ['#440154', '#46327e', '#365f8d', '#277b8d', '#1a9d8b', '#35b779', '#6ece58', '#b4de2c', '#fde725']
     color_palettes = {
         "Température": viridis_palette,
         "Précipitations": viridis_palette,
         "Humidité": viridis_palette,
     }

     attribute_limits = {
         "Température": {"vmin": 0, "vmax": 50},
         "Précipitations": {"vmin": 0, "vmax": 200},
         "Humidité": {"vmin": 0, "vmax": 0.99},
     }

     min_value = attribute_limits[selected_attribute]["vmin"]
     max_value = attribute_limits[selected_attribute]["vmax"]
     selected_palette = color_palettes[selected_attribute]


     m = leafmap.Map()
     m.split_map(image_name_left, image_name_right)

     color_map = LinearColormap(['#440154', '#46327e', '#365f8d', '#277b8d', '#1a9d8b', '#35b779', '#6ece58', '#b4de2c', '#fde725'], vmin=min_value, vmax=max_value)

     if selected_attribute == "Température":
         color_map.caption = f"{selected_attribute} (°C)"
     elif selected_attribute == "Précipitations":
         color_map.caption = f"{selected_attribute} (mm)"
     elif selected_attribute == "Humidité":
         color_map.caption = f"{selected_attribute} (%)"

     m.add_child(color_map)
     st_folium_static(m, width=1500, height=800)







with tab4:
  with st.container():
    def flannery_compensation(original_size, attribute_value):
        return original_size * math.sqrt(attribute_value / math.pi)

    def save_uploaded_file(file_content, file_name):
        _, file_extension = os.path.splitext(file_name)
        file_id = str(uuid.uuid4())
        file_path = os.path.join(tempfile.gettempdir(), f"{file_id}{file_extension}")

        with open(file_path, "wb") as file:
            file.write(file_content.getbuffer())

        return file_path
    colm1,colm2=st.columns(2)
    with colm1:
          def app_geoparquet():
              st.markdown("<h3 class='turquoise-text'> Fichier Geoparquet</h3>", unsafe_allow_html=True)

              # Load GeoParquet file
              uploaded_file = st.file_uploader("charger votre  fichier GeoParquet", type=["parquet"], key="geoparquet_uploader")
              if uploaded_file is not None:
                  file_path = save_uploaded_file(uploaded_file, uploaded_file.name)
                  gdf = gpd.read_parquet(file_path)

                  # Allow the user to choose the attribute
                  selected_attribute = st.selectbox("Choisir un attribut", gdf.columns[12:])
                  start_time = time.time()
                  lon, lat = gdf.geometry.centroid.x.mean(), gdf.geometry.centroid.y.mean()
                  m = folium.Map(location=[lat, lon], zoom_start=6, control_scale=True, max_zoom=6, min_zoom=3)

                  # Add GeoDataFrame to the Folium map with CircleMarkers
                  for index, row in gdf.iterrows():
                      value = row[f"{selected_attribute}"]
                      value = float(value)
                      original_size = 3  # Adjust the original symbol size accordingly
                      radius = flannery_compensation(original_size, value)  # Adjust the multiplier based on your data
                      color = 'darkturquoise'  # You can customize the color based on your needs

                      folium.CircleMarker(
                          location=[row.geometry.y, row.geometry.x],
                          radius=radius,
                          color=color,
                          fill=True,
                          fill_color=color,
                          fill_opacity=0.6,
                          popup=f"{selected_attribute}: {value}",
                      ).add_to(m)
                  end_time = time.time()
                  folium_static(m)
                  visualization_time_seconds = end_time - start_time
                  st.write(f"Temps de visualisation : {visualization_time_seconds:.2f} seconds")
                  start_time = time.time()
                  filter_opti = st.selectbox("Entrer une requête:", ["Aucun", "Attributs", "Spatial"])
                  if filter_opti == "Attributs":
                      attribute_to_filter = st.selectbox("Choisir un attribut pour filtrer:", gdf.columns)

                      if 11 <= gdf.columns.get_loc(attribute_to_filter) <= 47:
                        min_value = st.text_input(f"Valeur minimale de {attribute_to_filter}:", "")
                        max_value = st.text_input(f"Valeur maximale de {attribute_to_filter}:", "")

                        if st.button("Appliquer le filtre attributaire"):
                            if min_value and max_value:
                                gdf = gdf[(gdf[attribute_to_filter] >= float(min_value)) & (gdf[attribute_to_filter] <= float(max_value))]
                            elif min_value:
                                gdf = gdf[gdf[attribute_to_filter] >= float(min_value)]
                            elif max_value:
                                gdf = gdf[gdf[attribute_to_filter] <= float(max_value)]
                      else:
                        # Non-numeric attribute filter with single value
                        attribute_value = st.text_input(f"Valeur de {attribute_to_filter}:", "")

                        if st.button("Appliquer le filtre attributaire"):
                            if attribute_value:
                                gdf = gdf[gdf[attribute_to_filter] == attribute_value]
                  elif filter_opti == "Spatial":
                  # Spatial filter
                    st.warning("Saisissez une requête spatiale(syntaxe GeoPandas).")
                    user_spatial_query = st.text_input("Requête spatiale:", "")
                  # Exemple:(geometry.x > -7.5) & (geometry.x < -7)

                    if user_spatial_query:
                          try:
                              gdf = gdf.query(user_spatial_query)
                              st.success("Filtre spatial appliqué avec succès.")

                              # Download button for the GeoJSON file
                              download_button = st.download_button(
                                  label="Télécharger le résultat en GeoJSON",
                                  data=gdf.to_json(),
                                  file_name="result.geojson",
                                  key="geojsonparquet_download",
                              )
                          except Exception as e:
                              st.error(f"Erreur lors de l'application du filtre spatial: {str(e)}")
                  end_time = time.time()
                  visualization_time_seconds = end_time - start_time
                  st.write(f"Temps exécution de la requête : {visualization_time_seconds:.2f} seconds")

          if __name__ == "__main__":
              app_geoparquet()
    with colm2:
        def app_geojson():
            st.markdown("<h3 class='turquoise-text'> Fichier Geojson</h3>", unsafe_allow_html=True)

            # Load GeoJSON file
            uploaded_file = st.file_uploader("charger votre  fichier GeoJSON", type=["geojson", "json"], key="geojson_uploader")
            if uploaded_file is not None:
                geojson_content = uploaded_file.read()

                # Save the content to a temporary file in binary mode
                temp_file_path = "/tmp/temp_geojson.geojson"
                with open(temp_file_path, "wb") as temp_file:
                    temp_file.write(geojson_content)

                # Read the GeoJSON file using GeoPandas
                gdf = gpd.read_file(temp_file_path)

                selected_attribute = st.selectbox("Choisir un attribut", gdf.columns[11:])
                start_time = time.time()
                lon, lat = gdf.geometry.centroid.x.mean(), gdf.geometry.centroid.y.mean()
                m = folium.Map(location=[lat, lon], zoom_start=5.3, control_scale=True, max_zoom=10, min_zoom=2)
                for index, row in gdf.iterrows():
                    value = row[f"{selected_attribute}"]
                    value = float(value)
                    original_size = 2
                    radius = flannery_compensation(original_size, value)
                    color = 'darkturquoise'

                    folium.CircleMarker(
                        location=[row.geometry.y, row.geometry.x],
                        radius=radius,
                        color=color,
                        fill=True,
                        fill_color=color,
                        fill_opacity=0.6,
                        popup=f"{selected_attribute}: {value}",
                    ).add_to(m)

                end_time = time.time()
                folium_static(m)
                visualization_time_seconds = end_time - start_time
                st.write(f"Temps de visualisation : {visualization_time_seconds:.2f} seconds")

                start_time = time.time()
                filter_optio = st.selectbox("Appliquer une requête:", ["Aucun", "Attributs", "Spatial"])
                if filter_optio == "Attributs":
                      attribute_to_filter = st.selectbox("Choisir un attribut pour filtrer:", gdf.columns)

                      if 11 <= gdf.columns.get_loc(attribute_to_filter) <= 47:
                        min_value = st.text_input(f"Valeur minimale de {attribute_to_filter}:", "")
                        max_value = st.text_input(f"Valeur maximale de {attribute_to_filter}:", "")

                        if st.button("Appliquer le filtre attributaire"):
                            if min_value and max_value:
                                gdf = gdf[(gdf[attribute_to_filter] >= float(min_value)) & (gdf[attribute_to_filter] <= float(max_value))]
                            elif min_value:
                                gdf = gdf[gdf[attribute_to_filter] >= float(min_value)]
                            elif max_value:
                                gdf = gdf[gdf[attribute_to_filter] <= float(max_value)]
                      else:
                        # Non-numeric attribute filter with single value
                        attribute_value = st.text_input(f"Valeur de {attribute_to_filter}:", "")

                        if st.button("Appliquer le filtre attributaire"):
                            if attribute_value:
                                gdf = gdf[gdf[attribute_to_filter] == attribute_value]

                elif filter_optio == "Spatial":
                  # Spatial filter
                  st.warning("Saisissez une requête spatiale(syntaxe GeoPandas).")
                  user_spatial_query = st.text_input("Requête:", "")
                  # Exemple:(geometry.x > -7.5) & (geometry.x < -7)

                  if user_spatial_query:
                          try:
                              gdf = gdf.query(user_spatial_query)
                              st.success("Filtre spatial executé avec succès.")

                              # Download button for the GeoJSON file
                              download_button = st.download_button(
                                  label="Télécharger le résultat en GeoJSON",
                                  data=gdf.to_json(),
                                  file_name="result.geojson",
                                  key="geojson_download",
                              )
                          except Exception as e:
                              st.error(f"Erreur lors de l'application du filtre spatial: {str(e)}")
                end_time = time.time()
                visualization_time_seconds = end_time - start_time
                st.write(f"Temps exécution de la requête : {visualization_time_seconds:.2f} seconds")


        if __name__ == "__main__":
            app_geojson()

  with st.container():
    co1,co2=st.columns(2)
    with co1:
        def read_geotiff(url):
            with rasterio.open(url) as src:
                data = src.read()
                transform = src.transform
                bounds = src.bounds
            return data, transform, bounds

        # Fonction pour créer une carte Folium avec le raster GeoTIFF
        def create_folium_map(data, transform, bounds):
            # Convertir le tableau raster en image
            image = reshape_as_image(data)

            # Obtenir les dimensions de l'image
            height, width, _ = image.shape

            # Calculer le centre de l'image
            center_lat = bounds.bottom + (bounds.top - bounds.bottom) / 2
            center_lon = bounds.left + (bounds.right - bounds.left) / 2

            # Créer une carte Folium centrée sur le centre de l'image
            m = folium.Map(location=[center_lat, center_lon], zoom_start=10)

            # Ajouter le raster GeoTIFF à la carte
            folium.raster_layers.ImageOverlay(
                image=image,
                bounds=[[bounds.bottom, bounds.left], [bounds.top, bounds.right]],
                opacity=1,
                interactive=True,
                cross_origin=False,
                colormap=lambda x: (0, 0, 0, x),
            ).add_to(m)

            return m

        # Titre de l'application Streamlit
        st.markdown("<h3 class='turquoise-text'>Visualisation TIFF avec Streamlit</h3>", unsafe_allow_html=True)

        # URL de votre GeoTIFF
        geotiff_url = st.text_input("https://cog-layout.s3.eu-north-1.amazonaws.com/image-cog/output_cog.tif")

        # Vérifier si une URL a été fournie
        if geotiff_url:
            # Charger le GeoTIFF
            geotiff_data, geotiff_transform, geotiff_bounds = read_geotiff(geotiff_url)
            start_time = time.time()
            # Créer la carte Folium avec le GeoTIFF
            folium_map = create_folium_map(geotiff_data, geotiff_transform, geotiff_bounds)

            # Afficher la carte Folium dans Streamlit
            folium_static(folium_map)
            end_time = time.time()
            elapsed_time = end_time - start_time
            st.write(f"Temps de visualisation: {elapsed_time:.2f} seconds")
        else:
            st.warning("Veuillez entrer l'URL de votre GeoTIFF.")
    with co2:

          def read_tiff(url):
              with rasterio.open(url) as src:
                  data = src.read()
                  transform = src.transform
                  bounds = src.bounds
              return data, transform, bounds

          def create_folium_map(data, transform, bounds):
              # Convert the raster array to an image
              image = reshape_as_image(data)

              # Get the dimensions of the image
              height, width, _ = image.shape

              # Calculate the center of the image
              center_lat = bounds.bottom + (bounds.top - bounds.bottom) / 2
              center_lon = bounds.left + (bounds.right - bounds.left) / 2

              # Create a Folium map centered on the center of the image
              m = folium.Map(location=[center_lat, center_lon], zoom_start=5.3)

              # Add the TIFF raster to the map
              folium.raster_layers.ImageOverlay(
                  image=image,
                  bounds=[[bounds.bottom, bounds.left], [bounds.top, bounds.right]],
                  opacity=1,
                  interactive=True,
                  cross_origin=False,
                  colormap=lambda x: (0, 0, 0, x),
              ).add_to(m)

              return m

          # Streamlit application title
          st.markdown("<h3 class='turquoise-text'>Visualisation TIFF avec Streamlit</h3>", unsafe_allow_html=True)

          # URL of your TIFF file
          tiff_url = st.text_input("Enter URL de votre TIFF")

          # Check if a URL has been provided
          if tiff_url:
              # Load the TIFF file
              tiff_data, tiff_transform, tiff_bounds = read_tiff(tiff_url)
              start_time = time.time()

              # Create the Folium map with the TIFF file
              folium_map = create_folium_map(tiff_data, tiff_transform, tiff_bounds)

              # Display the Folium map in Streamlit
              folium_static(folium_map)
              end_time = time.time()
              elapsed_time = end_time - start_time
              st.write(f"Temps de visualisation: {elapsed_time:.2f} seconds")
          else:
              st.warning("Veuillez entrer l'URL de votre TIFF.")

"""Après l'exécution du code ci-dessus, suivez en exécutant le code ci-dessous. Ensuite, copiez 'External URL' sans inclure "http://" et ":8501" en cliquant sur "Your URL is". Vous serez redirigé vers une autre page où vous pourrez récupérer le chemin. Collez simplement cet URL pour accéder à votre application

## Streamlit runing page
"""

!streamlit run vecteur.py & npx localtunnel --port 8501